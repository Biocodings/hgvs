# HGVS Grammar
# 2013-09-16 10:25 Reece Hart <reecehart@gmail.com>

# DIAGRAM OF HGVS PARSER ELEMENTS
# For the purposes of this grammar, an HGVS variant is limited to the subset
# of the Mutnomen document [3] that defines variant positions reasonably
# precisely.
#
# The basic structure of an HGVS variant is:
#    <ac>:<type>.<posedits>
# where ac is a sequence accession, type determines the sequence type and
# coordinate system ([cgmnpr]), and posedits is a list of positions and edit
# operations.
# 
# The easiest way to describe this grammar is by way of example. For the
# variant
#     NM_01234.5:c.[12A>C;34-56_78+90G>T]
# we parse it into these components:
#     NM_01234.5 : c . [ 12 A>C ; 34 -56 _ 78 +90 del ]
#     -----------------------------------------------    hgvs_variant (sp. c_variant)
#     ----------   -     ----------------------------    ac, type, edits (a list)
#                        ------   -------------------    posedits (2)
#                        -- ---   --------------- ---    int,edit pairs
#                        -- - -   ------   ------ ---    int = <start,end>; edit = <ref,alt>
#                        --       -- ---   -- ---        pos = <base,offset>
#
# In addition to the above, this grammar also supports "HGVS-lite" notations for position.
#     NM_01234.5:c.56
# The hgvs_lite rule consists of a ref sequence, type, and position.
#
# References:
# 1. http://www.hgvs.org/mutnomen/
# 2. Describing structural changes by extending HGVS sequence variation nomenclature.
#    http://www.ncbi.nlm.nih.gov/pubmed/21309030
# 3. A formalized description of the standard human variant nomenclature...
#    http://www.ncbi.nlm.nih.gov/pubmed/21992071


#
# QUESTIONS
# * grammar versions: 1, 2, lax, strict, etc
# * validation: strict
# * position singletons: cds_start_Position, cds_end_Position, 
#
# UNIMPLEMENTED -- TBD
# * inversion
# * IVS#, EX#
# * eq/unk effect (=, ?)
# * complex variants (c.[];[] or c.[;])
#
# UNIMPLEMENTED -- PURPOSEFULLY EXCLUDED FOR NOW
# Many symbols suggested in Laros et al have been purposefully excluded.  They are
# listed below with brief rationale:
# * d, u (downstream, upstream) -- By definition, these refer to positions
# outside the transcript, which necessarily means that the identity of the
# position depends on external data. 
# * gene symbols (and gene symbol suffixes, _i and _v) -- these do not
# refer to a sequence precisely. 
# * other uncertainty (e.g., '(;)')
# * non-measurements (e.g., 'p.0')
# * uncertain positions (?)



############################################################################
## Top-level parser
# Each of these right-hand productions is expected to return a Variant
# instance

# any_variant: lax syntactic parser
any_variant = accn:ac ':' any_type:type '.' any_posedits:posedits -> Variant(ac,type,posedits)
any_type = :x ?(x in 'cgmnpr') -> x
any_posedits = <anything+>

hgvs_variant = c_variant

c_variant = accn:ac ':' 'c':type '.' c_interval:interval c_edits:edits -> Variant(ac,type,edits)

c_edits = c_edit

c_edit = c_pos 



############################################################################
## Edits

dna_edit = dna_subst | dna_delins | dna_ins | dna_del | dna_dup
dna_del = 'del' (<num>|<dna*>):pre -> DelIns(pre=pre,post=None)
dna_delins = 'del' (<num>|<dna*>):pre 'ins' <dna+>:post  -> DelIns(pre=pre,post=post)
dna_dup = 'dup' <dna*>:seq -> Dup(seq=seq)
dna_ins = 'ins' <dna+>:post -> DelIns(pre=None,post=post)
dna_subst = dna:pre '>' dna:post -> DelIns(pre=pre,post=post)

rna_edit = Not_Yet_Implemented


############################################################################
## Basic types

dna_seq = <dna+>
dna = :x ?(x in 'ACGTacgt') -> x

rna_seq = <rna+>
rna = :x ?(x in 'ACGUacgu') -> x

aa1_seq = <aa1+>
aa1 = :x ?(x in 'ACDEFGHIKLMNPQRSTVWY') -> x

aa3_seq = <aa3+>
aa3 = :x ?(x in ['Ala','Cys','Asp','Glu','Phe','Gly','His','Iso','Lys','Leu',
				 'Met','Asn','Pro','Gln','Arg','Ser','Thr','Val','Trp','Tyr']) -> x

# MISSING: base +- '?'
# MISSING: uncertain positions ()
c_interval = (c_pos:start '_' c_pos:end -> Interval(start,end)) | (c_pos:start -> Interval(start,start))
c_pos = ('*' num:x -> CDSPosition(0,x)) 
		| ('-' num:x -> CDSPosition(0,-x))
		| (num:b (snum | -> 0):o -> CDSPosition(b,o))

interval = (pos:start '_' pos:end -> Interval(start,end)) | (pos:start -> Interval(start,start))
pos = num:pos -> Position(pos)

# Accessions, possibly versioned. Should accept, e.g., NM_01234.5, LRG_01234_1p1
accn = <letter letterOrDigit+ ('_' letterOrDigit+)? ('.' digit+)?>

snum = <pm? num>:x -> int(x)
num = <digit+>:x -> int(x)
pm = :x ?(x in '-+') -> x

Not_Yet_Implemented = 'NOT YET IMPLEMENTED'
